# 网页优化之关键渲染路径

优化关键渲染路径是指显示当前用户操作有关的内容

网页呈现的顺序：

    (1) 首先看看发出的HTML文档请求
    (2) 然后获得一个事件，表示服务器返回了一些响应标头
    (3) 标头后面跟着一些数据，这就是我们的HTML
    (4) 然后浏览器开始解析HTML，这里浏览器将收到的内容转换成DOM树
    (5) 实际上，展开这些解析的节点，可以看到文档解析器找到了嵌入的图片资料(如果有图片的话)，并发起请求，
        继续解析HTML，结束后就会构建CSS对象模型
    (6) 接着浏览器构建渲染树，并计算出应该在屏幕上可见的所有内容样式，就是这个recalculate style事件所
        表示的。完成后，我们能继续转到布局步骤。
    (7) 最后，我们发出绘制事件，我们的页面就呈现在屏幕上了。
  
优化DOM

     注释对于开发者来说非常有用，但浏览器遇到这些解析器时，会忽略：
      (1) 缩小文件，如删掉注释
      (2) 压缩文件
      (3) 确认浏览器缓存了这些内容
        
优化网页上的各种资源时，技术和思维方式：预处理、环境特定优化以及不同的内容采用不同的算法。

通过GZIP压缩文本
  
    GZIP对基于文本的资产的压缩效果最好：css、JS和HTML;所有现代浏览器都支持GZIP压缩，并会自动请求该压缩。
  
HTTP缓存

    通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信。这会延迟浏
    览器获得和处理内容的时间，还会增加访问者的流量费。因此缓存并重复利用之前获取的资源能力成为性能优化的
    一个关键方面。
    
每个浏览器都自带HTTP缓存实现功能，你只需要确保每个服务器响应都提供正确的HTTP标头指令，以指示浏览器何时
可以缓存响应以及可以缓存多久。

当服务器返回响应时，还会发出一组HTTP标头，用于描述响应的内容类型、长度、缓存指令、验证令牌等。

通过ETag验证缓存的响应

    服务器使用ETag HTTP标头传递验证令牌
    验证令牌可实现高效的资源更新检查：资源未发生变化时不会传送任何数据。
    浏览器会自动检测之前是否指定了验证令牌，它会将验证令牌追加到发出请求上，并且它会根据从服务器接收的
    响应在必要时更新缓存时间戳。我们唯一要做的就是确保服务器提供必要的ETag令牌。检查你的服务器文档中
    有无必要的配置标志。
    
阻塞渲染CSS

    默认情况下，css被视为阻塞渲染资源，这意味着浏览器将不会渲染任何已处理的内容，直至CSSOM构建完毕。
    
    在渲染树构建中，我们看到关键渲染路径要求我们同时具有DOM和CSSOM才能构建渲染树。这会给性能造成严重
    影响：HTML和CSS都是阻塞渲染的资源。HTML显示是必要的，因为如果没有DOM，我们就没有可渲染的内容。
    
    我们可以通过媒体类型和媒体查询将一些CSS资源标记为不阻塞渲染。浏览器会下载所有内容，无论阻塞还是
    不阻塞。
    
    CSS是阻塞渲染的资源，需要将它今早、尽快地下载到客户端，以便缩短首次渲染的时间。
  
外部JS依赖

    到我们遇到<script>标记时，我们必须暂停DOM构建过程，让JS先运行然后才能继续，JS会阻止解析，因为
    当我们遇到标记时，它会阻止DOM进行构建。但JS执行很快。但是当<script>中的是外部文件时，访问外部
    文件需要时间，会拖延渲染的速度。但并不是全部写内联JS就好，因为：
      内联JS会减少请求次数，但也有缺陷；在多个网页使用相同代码，就会出现多余的操作，需要权衡。
        
异步JS

    在网页加载后，加载脚本。当网页加载完毕后，浏览器就会发出onload事件。
    默认情况下，所有JS都会阻止解析器。由于浏览器不了解脚本计划在页面上执行什么操作，它会做最坏的
    假设并阻止解析器。向浏览器传递脚本不需要在引用位置执行的信号，既可以让浏览器继续构建DOM，也
    能够让脚本在就绪后执行；例如，在从缓存或远程服务器获取文件后执行。
    
    为脚本添加异步的方法：
    <script src='app.js' async></script>

    向script标记添加异步关键字可以指示浏览器在等待脚本可用期间不阻止DOM构建，这样可以显著提升性能。
    
    async这个属性具有两个重要的特性：
      (1) 首先，它告诉浏览器当浏览器遇到标记时，它不需要阻止DOM构建过程，因此浏览器会忽略脚本请求，
          继续解析DOM。
      (2) 其次，脚本不会因CSS对象模型而遭到阻止，所以如果在CSS对象模型准备好前，脚本就可用了，依然
          会立即被执行。
          
        内联脚本上不能添加async属性，依然会遇到CSS对象模型的阻止，但可以将JS放到CSS上方，则JS执行
        不会遇到CSS阻止。
    
    
JS的加载三种方法：

阻止(Blocking):```<script src="example.js"></script>```

内联(Inline):```<script>document.write("this is an inline script.")</script>```

异步(Async):```<script async src='example.js' ></script>```


一般策略和CRP图表

    (1) 缩小，压缩和缓存(都适用于html、CSS和JS)
    (2) 最小化使用渲染阻止资源(使用媒体查询来取消呈现以及内联CSS)
    (3) JS会阻止文档解析，最小化使用解析器阻止资源(推迟JS执行过程，‘defer’或标记中使用‘asyc’属性)

以上都是通过减小通过网络发送数据量、减少关键资源的数量、缩短关键呈现路径(CRP)的长度来实现的



    



