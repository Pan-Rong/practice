# JS学习笔记
**1、 函数中参数 parameters 和 arguments区别**

    函数的parameters是函数被定义是列出的参数，为形参(formal parameter)
    函数arguments是函数调用时的真实值;parameters是arguments初始化时的值.
[详情](https://developer.mozilla.org/en-US/docs/Glossary/Parameter)

**2、javascript中arguments对象**
   
    arguments 是一个对应于传递给函数的参数的类数组对象。
    arguments对象是所有（非箭头）函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数
    的每个参数的条目，第一个条目的索引从0开始。例如，如果一个函数传递了三个参数，你可以以如下方式引用他们：
```
  arguments[0]
  arguments[1]
  arguments[2]
```
    arguments对象不是一个 Array 。它类似于Array，但除了长度之外没有任何Array属性.
[详情](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments)

**3、JS中异步编程的4种方法** [详情连接](http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)
    
    (1)回调函数
    
    (2)事件监听，jQuery中就是绑定事件，纯JS中是添加监听器
    
    (3)发布和订阅模式(publish-subscribe pattern)
    
    (4)promises模式  


## JS总体概述

**基础语法**

    基础语法包括：变量声明、数据类型、函数、控制语句、内置对象等
    
    在ES5中，变量声明有两种方式：var 和function。var用于声明普通的变量，接收任意类型；function用于声明函数。ES6新增了let、
    const、import和class等，分别用于声明普通变量、静态变量、模块和类。
    
    JS数据类型有六种：分别是String、Number、Boolean、Null、Undefined和Object等。另ES6新增了Symbol类型。其中Object是引用类型
    其他是原始类型。
    
    原始类型即基本类型或简单类型。因为其占据空间固定，是简单的数据段，为了方便提升变量查询速度，将其存储在栈(stack)中(按值操作)。
    为了方便操作，ECMAScript提供了3个基本包装类型：Boolean、Number和String。基本包装类型是特殊的引用类型，每当读取一个基本类型
    值的时候，JS内部就会创建一个对应的包装对象，从而可以调用一些方法来操作这些数据。
    
    引用类型由于其值大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此其存储在堆(heap)中，存储在变量处的值是一个指针。
    指向存储对象的内存处(按址访问)，对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法；但基本类型不可以添加属
    性和方法。
    
    JS可以通过typeof来判断原始数据类型，但不能判断引用类型，要知道引用类型的具体类型，需要通过Object原型上的toString方法来判断。
    
    JS中函数存在着三种角色：普通函数、构造函数、对象方法。同一个函数，调用方式不同，函数的作用不一样，所扮演的角色也不一样。直接调
    用时就是普通函数，通过new创建对象时就是构造函数，通过对象调用时就是方法。
    
    JS常用的内置对象有window、Date、Array、JSON、RegExp等。window是浏览器在执行脚本时创建的一个全局对象，主要描述浏览器窗口相关
    属性和状态.JSON主要用于对象的序列化和反序列化，还有一个作用就是实现对象的深拷贝。RegExp即正则表达式，处理字符串的利器。
    
**1、函数原型链**

    JS是一种基于对象的语言，为了具备继承能力，JS在函数对象上建立了原型对象prototype，并以函数对象为主线，从上至下，在JS内部构建了一
    条原型链。原型链把一个个独立的对象联系在一起。Object是所有对象的祖宗，任何对象所建立的原型链最终都指向Object，并以Object终结。
    
    简单来说就是建立了变量查询机制，当访问一个对象的属性时，先查找对象本身是否存在，如果不存在就去该对象所在的原型链上去找，直到
    Object对象为止，如果都没有找到该属性，才会返回undefined。因此可以实现继承。
    
**2、函数作用域**

    函数作用域就是变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。因此，JS中没有块级作用域，只有函数作用域。这个
    设计导致了JS中出现了变量提升的问题。简单来说就是，将变量声明提升到它所在作用域的最开始部分，为了解决变量提升带来的副作用，ES6新
    增了let命令来声明变量，let所声明的变量只在let命令所在的代码块内有效，所以不存在变量提升问题。
    
**3、this指针**

    this指针存在于函数中，用以标识函数运行时所处的上下文。函数的类型不同、this指向规则也不一样：对于普通函数：this始终指向全局对象
    window；对于构造函数，this则指向新创建的对象；对于方法，this指向调用该方法的对象。另，Function对象也提供了call、apply和bind等
    方法来改变函数的this指向，其中，call和apply主动执行函数、bind一般在事件回调中使用，而call和apply的区别只是参数的传递方式不同。
    
    从本质上来说，无论什么函数、this是否被改变，this均指向触发函数运行时的那个对象。而在函数运行时，this的值是不能被改变的。
    
**4、new操作符**

    函数的创建有三种方式，即显示声明、匿名定义和new Function().JS中的函数既可以是函数，也可以是方法，还可以是构造函数。当使用new来
    创建对象时，该函数就是构造函数，JS将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新
    对象可以访问函数对象原型prototype中的方法和属性。
    
**5、闭包**

    闭包是一个具有独立作用域的静态执行环境(即当函数执行完后，它还可以调用该函数里的值).和函数作用域不同的是，闭包的作用域是静态的，可
    以永久保存局部资源，而函数作用域只存在于运行时，函数执行结束后立即销毁。
    
**6、单线程和异步队列**

    JS是单线程语言，在浏览器中，当JS代码被加载时，浏览器会为其分配一个主线程来执行任务(函数)，主线程会形成一个全局执行环境，执行环境在
    栈中采用后进先出(LIFO)的顺序来执行代码块，以保证所有的函数能按照正确的顺序被执行。
    
    但在浏览器中，有一些任务是非常耗时的，比如ajax请求、定时器、事件等，为了保证非耗时任务不受影响，JS在执行环境中维护了一个异步队列(也
    叫工作线程)，并将这些耗时任务放入队列中进行等待，这些任务的执行时机并不确定，只有当主线程的任务执行完成以后，主线程才会去检查异步队
    列中任务是否需要并开始执行。
    
    JS中的setTimeout和setInterval就是典型的异步操作，它们会被放入异步队列中等待，即使setTimeout(0)也不会被立刻执行，需要等待到当前同步
    任务结束后才会被执行。
    
**7、异步通信Ajax技术**

    Ajax是浏览器专门用来和服务器进行交互的异步通讯技术，其核心对象是XMLHttpRequest，通过该对象可以创建一个Ajax请求。Ajax请求是一个耗时的
    异步操作，当请求发出以后，Ajax提供了两个状态位来描述请求在不同阶段的状态，这两个状态位分别是readyState和status,readyState通过5个状态
    码来描述一个请求的5个阶段：
        0-请求未发送，初始化阶段
        1-请求发送中，服务器还未收到请求
        2-请求发送成功，服务器已收到请求
        3-服务器处理完成，开始响应请求，传输数据
        4-客户端收到请求，并完成了数据下载，生成了响应对象
    status用于描述服务端对请求处理的情况，200表示正确响应了请求，404表示服务器找不到资源，500代表服务器内部异常等等。
    
    Ajax对象还可以设置一个timeout值，代表超时时间，切记：timeout只会影响readyState,而不会影响status，因为超时只会中断数据传输，但不会影响
    服务器的处理结果。如果timeout设置的不合理，就会导致响应码status是200，但response里却没有数据，这种情况就是服务器正确响应了请求，但数据
    的下载被超时中断了。
    
    为了防止XSS攻击(跨站脚本攻击[Cross Site Scripting]),浏览器对Ajax请求做了限制，不允许Ajax跨域请求服务器，只允许请求和当前地址同域的服
    务器资源。但不限制脚本和标签发送跨域请求，比如：script和img标签，因此可以利用脚本跨越能力来实现跨越请求，即JSONP的原理。
    
    JSONP虽然可以解决跨越问题，但只能是get请求，并没有有效的错误捕获机制，为了解决这个问题，XMLHttpRequest Level2提出了CORS模型，即跨域资
    源共享，它不是一个新API，而是一个标准规范，当浏览器发现该请求需要跨域时，就会自动在头信息中添加一个Origin字段，用以说明本次请求来自哪个
    源。服务器根据这个值，决定是否同意这次请求。
    
    随着移动端的快速发展，Web技术的应用场景正在变得越来越复杂，关注点分离原则在系统设计层面就显得越来越重要，而XMLHttpRequest是Ajax最古老
    的一个接口，因而不太符合现代化的系统设计理念。因此，浏览器提供了一个新的Ajax接口，即Fetch API，Fetch API是基于Promise思想设计的，更符
    合关注点分离原则。
    
    关注点分离的大体思路是,先将复杂问题做合理的分解,再分别仔细研究问题的不同侧面(关注点),最后综合各方面的结果,合成整体的解决方案。
   
**8、模块化[模块化详解]()**

    JS规范一直没有模块(module)体系，即无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。模块就是实现特定功能的文件。
    
    在ES6之前，为了实现JS模块化编程，社区制定了一些模块加载方案，最主要有CMD和AMD两种，分别是commonjs和Seajs为代表。
    
    ES6在
    语法标准的层面上，实现了模块化编程，其设计思想是，尽量静态化，使得编译时就能确定模块的依赖关系，即编译时加载，而CMD和AMD是在运行时
    确定依赖关系，即运行时加载
    
**9、Node.js** 
   
   Node.js是一个基于Chrome V8引擎的JS运行环境，它的运行不依赖浏览器作为宿主环境，而是和服务端程序一样可以独立的运行，这使得JS编程第一
   次从客户端被带到了服务端。Node.js在服务端的优势是，它采用单线程和异步I/O模型，实现了一个高并发、高性能的运行环境。相比传统的多线程
   模型，Node.js实现简单，并可减少资源开销。
   
**10、ES6**   
   
   ES6是ECMAScript 6.0的简写，即JS语言的下一代标准，已经在2015年6月正式发布了，它的目标是让JS能够方便的开发企业级大型应用程序，因此，
   ES6的一些规范正在逐渐向JAVA、C#等后端语言标准靠近。ES6规范中，比较重大的变化如下(具体可看ES6的学习笔记)：
    (1)新增let、const命令来声明变量；
        和var相比，let声明的变量不存在变量提升问题，但没有改变JS弱类型的特点，依然可以接受任意类型变量的声明；const声明的变量不允许
        在后续逻辑中改变，提高了JS语法的严谨性。
     (2)新增解构赋值、剩余语法、箭头函数等
     (3)新增模块化，这是JS走向规范比较重要的一步，让前端更方便的实现工程化
     (4)新增类和继承的概念
     (5)新增模板字符串功能
     (6)新增Promise对象，解决异步回调多层嵌套的问题
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
